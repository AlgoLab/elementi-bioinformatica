\usepackage[italian]{babel}
\usepackage[utf8]{inputenc}
\usepackage{pgf}
\usepackage{verbatim}
\usepackage{inconsolata}
\usepackage{listings}
\lstset{language=C, frame=single,
  basicstyle=\scriptsize\ttfamily,
  numbers=left, numberstyle=\tiny\color{gray},
   numbersep=5pt, fancyvrb=true
}

\usepackage{url}
\usepackage{xmpmulti}
% \usepackage{euler}
\usepackage[T1]{fontenc}
\pdfpagebox5
\immediate\write18{sh ./vc}
\input{vc}

\author{Gianluca Della Vedova}
\title{Elementi di Bioinformatica}
\institute{Univ. Milano--Bicocca\\
  \texttt{http://gianluca.dellavedova.org}}
\date{\today, {\tiny revisione \VCRevision}}
%\pgfdeclareimage[height=1cm]{university-logo}{logounimib}
%\logo{\pgfuseimage{university-logo}}



% If you wish to uncover everything in a step-wise fashion, uncomment
% the following command:
\beamerdefaultoverlayspecification{<+->}

\graphicspath{{figures/}}


\begin{document}
\begin{frame}
  \titlepage
\end{frame}


\begin{frame}\frametitle{Gianluca Della Vedova}
\begin{itemize}
\item
Elementi di Bioinformatica
\item
Ufficio U14-2041
\item
\url{http://gianluca.dellavedova.org}
\item
\url{http://algolab.eu/didattica/elementi-di-bioinformatica}
\item
\url{gianluca.dellavedova@unimib.it}
\end{itemize}
\end{frame}

\begin{frame}[fragile]
\frametitle{Notazione}
\begin{itemize}
\item
\alert{simbolo}: $T[i]$\\
\item
\alert{stringa}: $T[1]T[2]\cdots T[l]$\\
\item
\alert{sottostringa}: $T[i:j]$\\
\item
\alert{prefisso}: $T[:j]=T[1:j]$\\
\item
\alert{suffisso}: $T[i:]=T[i:|T|]$
\item
\alert{concatenazione}: $T_{1}\cdot T_{2} = T_{1}T_{2}$
\end{itemize}
\end{frame}


\begin{frame}[fragile]
\frametitle{Pattern Matching}
\begin{block}{Problema}
\alert{Input}: testo $T=T[1]\cdots T[n]$, pattern $P=P[1]\cdots P[m]$, alfabeto $\Sigma$\\
\alert{Goal}: trovare \emph{tutte} le occorrenze di $P$ in $T$\\
\alert{Goal}: trovare tutti gli $i$ tale che $T[i]\cdots T[i+m-1]=P$
\end{block}
\begin{block}{Algoritmo banale}
\alert{Tempo}: $O(nm)$
\end{block}
\begin{block}{Lower bound}
\alert{Tempo}: $O(n+m)$
\end{block}
\end{frame}

\begin{frame}
\frametitle{Bit-parallel}
\begin{block}{Algoritmi seminumerici}
\begin{itemize}
\item
$25$
\item
$25=00011001$
\item
$25=00011001=$FFFTTFFT
\end{itemize}
\end{block}
\begin{block}{Operazioni bit-level}
\alert{Or}: $x\lor y$, \alert{And}: $x\land y$, \alert{Xor}: $x\oplus y$\\
\alert{Left Shift}: $x << k$, \alert{Right Shift}: $x >> k$,
\begin{itemize}
\item
Tutte bitwise
\item
Tutte in hardware
\end{itemize}
\end{block}
\end{frame}

\begin{frame}
\frametitle{D\"om\"olki / Baeza-Yates, Gonnet}
\begin{block}{Matrice $M$}
$M(i,j)=1$ sse $P[:i]=T[j-i+1:j]$\\
$0\le i\le m$, $0\le j\le n$
\end{block}
\begin{block}{Occorrenza di $P$ in $T$}
$M(m,j)=1$
\end{block}
\begin{itemize}
\item
$M(0,\cdot)=1$, $M(\cdot,0)=0$
\item
\alert{$M(i,j)=1$} sse $M(i-1, j-1)=1$ AND $P[i]=T[j]$
\end{itemize}
\end{frame}

\begin{frame}
\frametitle{Esempio}
\begin{block}{Esempio}
$T$=abracadabra\\
$P$=abr
\end{block}

\begin{center}
\begin{tabular}[l]{ll}
%\hline{1}
10010101001\\
01000000100\\
00100000010&$\leftarrow$ \alert{occorrenze}\\%\hline
\end{tabular}
\end{center}

\begin{block}{Matrice $M$}
1 colonna = 1 numero
\end{block}
\end{frame}

\begin{frame}[fragile]
\frametitle{Colonne}
$U[\sigma]$ = array di bit dove $U[\sigma,i]=1$ sse $P[i]=\sigma$

\begin{block}{$C[j]$ da $C[j-1]$}
\begin{itemize}
\item
Right shift di $C[j-1]$
\item
$1$ in prima posizione
\item
AND con $U[T[j-1]]$
\item
\alert{w}: word size
\item
C[j] = ((C[j-1] >> 1) || (1 << (w-1))) \& U[T[j]];
\end{itemize}
\end{block}
\end{frame}

\begin{frame}[fragile]
\frametitle{Note}
\begin{itemize}
\item
Tempo $O(n)$ se $m\le w$
\item
Tempo $O(nm)$
\item
No condizioni
\item
$w<m\le 2w$?
\end{itemize}
\end{frame}

\begin{frame}[fragile]
\frametitle{Karp-Rabin}
\begin{block}{Alfabeto binario}
\begin{itemize}
\item
$H(S)=\sum_{i=1}^{|S|} 2^{i-1}H[i]$
\item
sliding window di ampiezza $m$ su $T$
\item
$H(T[i+1:i+m]) =$\\
$=\left(H(T[i:i+m-1]) - T[i] \right) / 2 + 2^{m-1}T[i+m-1]$
\item
operazioni su bit
\item
$T[i:i+m-1]=P \Leftrightarrow H(T[i:i+m-1])=H(P)$
\end{itemize}
\end{block}
\end{frame}

\begin{frame}[fragile]
\frametitle{Karp-Rabin: problema}
\begin{block}{Numeri troppo grandi}
\begin{itemize}
\item
Modello RAM: numeri $O(n+m)$
\item
mod $p$
\item
$H(T[i+1:i+m]) =$\\
$\left(\left(H(T[i:i+m-1]) - T[i] \right) / 2 + 2^{m-1}T[i+m] \right)\mod p$
\item \textbf{NO}
\item
$2^{m-1}T[i+m] \mod p$ calcolato iterativamente, $\mod p$ ad ogni passo
\end{itemize}
\end{block}
\end{frame}

\begin{frame}[fragile]
\frametitle{Karp-Rabin: falsi positivi}
\begin{block}{Possibili errori}
\begin{itemize}
\item
Falso positivo (FP): occorrenza non vera
\item
Falso negativo (FN): occorrenza non trovata
\item
$H(T[i:i+m-1])=H(P) \Leftrightarrow T[i:i+m-1]=P$
\item
$H(T[i:i+m-1])  \mod p = H(P)  \mod p$
$\Leftarrow T[i:i+m-1]=P$
\end{itemize}
\end{block}
\end{frame}


\begin{frame}[fragile]
\frametitle{Karp-Rabin: falsi positivi}
\begin{block}{Probabilità di errore}
$P[\#FP\ge 1] \le O(nm/I)$ se il numero primo $p$ è scelto fra tutti i primi $\le
I$
\end{block}

\begin{block}{Valori di $I$}
\begin{itemize}
\item
$I=nm^{2} \Rightarrow P[\#FP\ge 1] \le 2.54/m$
\item
$I=n^{2}m  \Rightarrow P[\#FP\ge 1] \in O(1/n)$
\end{itemize}
\end{block}

\begin{block}{Abbassare probabilità di errore}
Scegliere $k$ primi casuali (indipendenti senza ripetizioni), cambiare primo
dopo ogni FP
\end{block}
\end{frame}

\begin{frame}[fragile]
\frametitle{Las Vegas vs.
  Monte Carlo}
\begin{block}{Classificazione algoritmi probabilistici}
\begin{itemize}
\item
Las Vegas:
\begin{itemize}
\item
Sempre corretto
\item
Forse non in tempo polinomiale
\item
Quicksort con pivot random
\end{itemize}
\item
Monte Carlo:
\begin{itemize}
\item
Sempre tempo polinomiale
\item
Forse non corretto
\item
Karp-Rabin
\end{itemize}
\end{itemize}
\end{block}
\end{frame}


\begin{frame}[fragile]
\frametitle{Controllo falsi positivi}
$L$: posizioni iniziali in $T$ delle occorrenze
\begin{block}{Run}
sequenza $\langle l_{1}, \ldots, l_{k}\rangle$ di posizioni in $L$ distanti al
massimo $n/2$
\end{block}

\begin{itemize}
\item
$d=l_{2}-l_{1}$
\item
$P$ semiperiodico con periodo $d$
\item
$P=\alpha\beta^{k-1}$, $\alpha$ suffisso di $\beta$
\item
ogni run occupa $\ge n$ caratteri di $T$
\item
ogni carattere  di $T$ è in max $2$ run
\end{itemize}
\end{frame}


\begin{frame}[fragile]
\frametitle{Trie}
\begin{columns}
\begin{column}{0.6\textwidth}
\begin{block}{Trie}
\begin{itemize}
\item
Albero
\item
Query: parola $\in$ dizionario
\item
archi etichettati
\item
Percorso radice-foglia = parola
\end{itemize}
\end{block}
\begin{block}{Dizionario}
ABRACADABRA\\
ARRAY\\
\uncover<3->{\alert{ABRA}}
\end{block}
\end{column}
\begin{column}{0.4\textwidth}
\begin{center}
\onslide<2-3>{\includegraphics[width=\textwidth]{trie1}}
%\onslide<4->{\includegraphics[width=\textwidth]{trie3}}
\end{center}
\end{column}
\end{columns}
\end{frame}

\begin{frame}[fragile]
\frametitle{Trie}
\begin{columns}
\begin{column}{0.6\textwidth}
\begin{block}{Terminatore}
\$ non appartiene all'alfabeto
\end{block}
\begin{block}{Dizionario}
ABRACADABRA\$\\
ARRAY\$\\
ABRA\$
\end{block}
\end{column}
\begin{column}{0.4\textwidth}
\begin{center}
\onslide<2->{\includegraphics[width=\textwidth]{trie4}}
\end{center}
\end{column}
\end{columns}
\end{frame}

\begin{frame}[fragile]
\frametitle{Suffix tree}
\begin{columns}
\begin{column}{0.5\textwidth}
\begin{block}{Definizione}
\begin{itemize}
% \item
% Testo $T$
\item
Trie compatto di tutti i suffissi di $T\$$
\item
Le etichette degli archi uscenti da $x$ iniziano con simboli diversi
\item
suffissi $\Leftrightarrow$ percorso radice-foglia
\end{itemize}
\end{block}
\end{column}
\begin{column}{0.5\textwidth}
\begin{center}
\uncover<2->{\includegraphics[width=\textwidth]{Suffix_tree_BANANA}}
\end{center}
\end{column}
\end{columns}
\end{frame}

\begin{frame}[fragile]
\frametitle{Suffix tree 2}
\begin{block}{Definizione}
\begin{itemize}
\item
foglie etichettata con posizione inizio suffisso
\item
path-label$(x)$: concatenazione etichette
\item
string-depth$(x)$: lunghezza path-label$(x)$
\item
Spazio $20n$ bytes
\end{itemize}
\end{block}
\end{frame}

\begin{frame}[fragile]
\frametitle{Suffix array}
\begin{block}{Definizione}
\begin{itemize}
\item
Array dei suffissi in ordine lessicografico
\item
Posizioni iniziali del suffisso nell'array
\item
Spazio $4n$ bytes
\item
$Lcp[i]$: lunghezza prefisso comune $SA[i]$, $SA[i+1]$
\end{itemize}
\end{block}
\begin{block}{BANANA\$}
\begin{tabular}[l]{|c|l|l|l|l|l|l|l|}
\hline
$i$&0&1&2&3&4&5&6\\
$SA$&7&2&4&6&1&3&5\\
$Lcp$&0&1&3&0&0&2&-\\\hline
\end{tabular}
\end{block}
\end{frame}

\begin{frame}[fragile]
\frametitle{Da Suffix tree a Suffix array}
\begin{columns}
\begin{column}{0.5\textwidth}
\begin{itemize}
\item
Visita depth-first di $ST$
\item
archi uscenti di ogni nodo in ordine lessicografico
\item
$Lcp[i]$ = string-depth di $lca(i,i+1)$
\end{itemize}
\end{column}
\begin{column}{0.4\textwidth}
\begin{center}
\onslide<1->{\includegraphics[width=\textwidth]{Suffix_tree_BANANA}}
%\onslide<4->{\includegraphics[width=\textwidth]{trie3}}
\end{center}
\end{column}
\end{columns}
\end{frame}

\begin{frame}[fragile]
\frametitle{Da Suffix array a Suffix tree}
\begin{columns}
\begin{column}{0.5\textwidth}
\begin{itemize}
\item
$Lcp = 0$:  partizione $SA$
\item
corrispondono ai figli della radice
\item
ricorsione prendendo i numeri minimi
\end{itemize}
\begin{block}{BANANA\$}
\begin{tabular}[l]{|c|l|l|l|l|l|l|l|}
\hline
$i$&0&1&2&3&4&5&6\\
$SA$&7&2&4&6&1&3&5\\
$Lcp$&0&1&3&0&0&2&-\\\hline
\end{tabular}
\end{block}
\end{column}
\begin{column}{0.5\textwidth}
\begin{center}
\only<2>{\includegraphics[width=\textwidth]{Suffix_tree_BANANA-level1}}
\only<3>{\includegraphics[width=\textwidth]{Suffix_tree_BANANA-level2}}
\only<4>{\includegraphics[width=\textwidth]{Suffix_tree_BANANA-level3}}
\only<5>{\includegraphics[width=\textwidth]{Suffix_tree_BANANA}}
\end{center}
\end{column}
\end{columns}
\end{frame}

\begin{frame}[fragile]
\frametitle{Pattern matching su suffix array}
\begin{block}{Occorrenza $P$ in $T$}
Suffissi di $T$ che iniziano con $P$
\end{block}
\begin{block}{Ricerca in $SA$}
\begin{itemize}
\item
Ricerca dicotomica
\item
Tempo $O(m \log n)$ -- caso pessimo
\item
Controllare tutto $P$ ad ogni iterazione
\item
$log_{2} n$ iterazioni
\end{itemize}
\end{block}
\end{frame}

\begin{frame}[fragile]
\frametitle{Acceleranti 1}
\begin{columns}
\begin{column}{0.5\textwidth}
\begin{itemize}
\item
Intervallo $SA(L, R)$ di $SA$
\item
Elemento mediano $M$
\item
Tutti i suffissi in $SA(L,R)$ iniziano con uno stesso prefisso lungo $Lcp(SA[L],
SA[R])$
\item
Non confrontare con i primi $Lcp(SA[L], SA[R])$ caratteri
\end{itemize}
\end{column}
\begin{column}{0.4\textwidth}
\begin{center}
\onslide<1->{\multiinclude[<+>][start=1,format=pdf,graphics={width=0.95\textwidth}]{figures/SA-pattern-matching1}}
%\onslide<4->{\includegraphics[width=\textwidth]{trie3}}
\end{center}
\end{column}
\end{columns}
\end{frame}

\begin{frame}[fragile]
\frametitle{Acceleranti 2}
\begin{columns}[T]
\begin{column}[T]{0.6\textwidth}
\begin{block}{$l$: $lcp(L,P)$; $r$: $Lcp(R,P)$}
\begin{enumerate}
\item
Caso 1: $l>r$
\only<3->{\begin{itemize}\item
$Lcp(L,M)>l$\only<4->{$\Rightarrow M\gets L$}
\only<5->{\item
$Lcp(L,M)<l$\only<6->{$\Rightarrow$\\ $R\gets M, r\gets Lcp(M,P)$}}
\only<7->{\item
  $Lcp(L,M)=l$\only<8->{$\Rightarrow$ confronto $P[l+1:]$, $M[l+1:]$}
}\end{itemize}}
\only<9->{\item
  Caso 2: $l=r$
\only<10->{\begin{itemize}\item
  $Lcp(L,M)>l$
\only<11->{\item $Lcp(M,R)>l$}
\only<12->{\item $Lcp(L,M)=Lcp(M,R)=l$}
  \end{itemize}}}
\end{enumerate}
\end{block}
\end{column}
\begin{column}{0.38\textwidth}
\only<2->{\multiinclude[<+>][start=1,format=pdf,graphics={width=0.95\textwidth}]{figures/SA-accelerant}}
%\only<2->{\multiinclude[<alert@+| +->][start=1,format=pdf,graphics={width=0.95\textwidth}]{figures/SA-accelerant}}
\end{column}
\end{columns}
\end{frame}

\begin{frame}[fragile]
\frametitle{Acceleranti 2: calcolo $Lcp$ in tempo $O(n)$}
\begin{itemize}[<+->]
\item
Iterazione 1: $(L,R)=(1,n)$
\item
Iterazione 2: $(L,R)=(1,n/2)$ oppure $(n/2,n)$
\item
Iterazione $k$: $L = h\frac{n}{2^{k-1}}$, $R = (h+1)\frac{n}{2^{k-1}}$
\item
Iterazione $\lceil \log_{2}n\rceil$: $R=L+1$, $Lcp(h,h+1)$
\item
Iterazione $\lceil \log_{2}n\rceil -1$: aggrego i risultati dell'iterazione
$\lceil \log_{2}n\rceil$
\item
Iterazione $k$: $Lcp(h\frac{n}{2^{k-1}}, (h+1)\frac{n}{2^{k-1}})$
\item
$=\min\{Lcp(2h\frac{n}{2^{k}}, (2h+1)\frac{n}{2^{k}})$,
$Lcp((2h+1)\frac{n}{2^{k}}+1, (2h+2)\frac{n}{2^{k}})$,
$Lcp((2h+1)\frac{n}{2^{k}}), Lcp((2h+1)\frac{n}{2^{k}}+1)\}$
\end{itemize}
\end{frame}


\begin{frame}[fragile]
\frametitle{Acceleranti 2: calcolo $Lcp$ in tempo $O(n)$}
\multiinclude[<+>][start=1,format=pdf,graphics={width=0.95\textwidth}]{figures/SA-linear-Lcp}
\uncover<5->{Passaggio da $y$ a $z$ deve esistere}
\end{frame}

\begin{frame}
\frametitle{Acceleranti 2: Osservazione}
\begin{itemize}[<+->]
\item
Tempo per trovare un'occorrenza
\item
Tempo per trovare tutte le occorrenze?
\item
$O(n+m+k)$, per $k$ occorrenze
\end{itemize}
\end{frame}

\begin{frame}[fragile]
\frametitle{Costruzione di suffix array}
\begin{itemize}
\item
Alfabeto $\Sigma$ con $\sigma$ simboli, testo $T$ lungo $n$
\item
Aggrego triple di caratteri
\item
Alfabeto $\Sigma^{3}$ con $\sigma^{3}$ simboli, testo $T_{1}$ lungo $n/3$
\end{itemize}
\end{frame}






\begin{frame}[fragile]
\frametitle{Sottostringa comune più lunga}
\begin{block}{Due stringhe $s_{1}$ e $s_{2}$}
\begin{itemize}
\item
Suffix tree generalizzato = insieme di stringhe
\item
$ST(s_{1}\$_{1}s_{2}\$_{2})$
\item
Nodo $x$ con foglie di $s_{1}$ e $s_{2}$
\item
Sottostringa di $s_{1}$ e $s_{2}$
\item
$ST(s_{1}\$s_{2}\$)$
\item
Max string-depth
\end{itemize}
\end{block}
\end{frame}

\begin{frame}[fragile]
\frametitle{Sottostringa comune più lunga}
\begin{block}{$k$ stringhe $\{s_{1}, \ldots , s_{k}\}$}
\begin{itemize}
\item
Suffix tree generalizzato
\item
Vettore $C_{x}[1:k]$ per ogni nodo $x$
\item
$C_{x}[i]$: $x$ ha una foglia di $s_{i}$
\item
$C_{x} = \bigvee C$ sui figli di $C$
\item
Nodo $z$, $C_{z}=\bar{1}$
\item
Tempo $O(kn)$
\end{itemize}
\end{block}
\end{frame}


\begin{frame}[fragile]
\frametitle{Lowest common ancestor (lca)}
\begin{block}{Dati albero $T$ e 2 foglie $x$, $y$}
\begin{itemize}
\item
$z$ è antenato comune di $x$, $y$ se
$z$ è antenato di entrambi $x$ e $y$
\item
$z$ è lca di $x$, $y$ se:
\begin{enumerate}
\item
$z$ è antenato comune di $x$ e $y$
\item
nessun discendente di $z$ è antenato comune di $x$ e $y$
\end{enumerate}
\end{itemize}
\end{block}
\begin{block}{Proprietà}
\begin{itemize}
\item
Preprocessing di $T$ in tempo $O(n)$
\item
Calcolo lca$(x,y)$ in tempo $O(1)$
\item
Algoritmo complesso, ma pratico
\end{itemize}
\end{block}
\end{frame}

\begin{frame}[fragile]
\frametitle{Sottostringa comune più lunga di $k$ stringhe}
\begin{block}{Arricchimento $ST$}
\begin{itemize}
\item
$N_{x}[i]$: numero foglie di $s_{i}$ discendenti di $x$
\item
$N_{x}[i]=0$ o $1$ per ogni foglia
\item
$N_{x}[i]=$ somma dei figli
\item
$D_{x}[i]$: numero di duplicati di foglie di $s_{i}$ discendenti di $x$
\item
$N_{x}[i]=0 \Rightarrow D_{x}[i]=0$
\item
$N_{x}[i]=1 \Rightarrow D_{x}[i]=0$
\item
$N_{x}[i]\ge 1 \Rightarrow D_{x}[i]=N_{x}[i]-1$
\item
$N_{x}[i] - D_{x}[i] =$ \uncover<2->{$C_{x}[i]$}
\end{itemize}
\end{block}
\end{frame}

\begin{frame}[fragile]
\frametitle{Sottostringa comune più lunga di $k$ stringhe}
\begin{block}{Gestione $ST$}
\begin{itemize}
\item
Visita depth-first di $ST$
\item
$L_{i}$: lista ordinata delle foglie di $s_{i}$
\item
Per ogni coppia $x,y$ consecutiva in $L_{i}$
\begin{enumerate}
\item
$z\gets lca(x,y)$
\item
$D_{z}[i]=$
\item
Aggiorna $C_{z}$
\end{enumerate}
\end{itemize}
\end{block}
\end{frame}

\begin{frame}[fragile]
\frametitle{Allineamento di 2 sequenze. Allineamento multiplo.}
\end{frame}

\begin{frame}[fragile]
\frametitle{Allineamento con gap generici, affini, convessi.}
\end{frame}

\begin{frame}[fragile]
\frametitle{Allineamento con banda. Algoritmo di Carrillo-Lipman}
\end{frame}

\begin{frame}[fragile]
\frametitle{BWA-SW}
\end{frame}

\begin{frame}[fragile]
\frametitle{SamTools}
\end{frame}

\begin{frame}[fragile]
\frametitle{Filogenesi. Neighbor-Joining.}
\end{frame}

\begin{frame}[fragile]
\frametitle{Clearcut}
\end{frame}

\begin{frame}[fragile]
\frametitle{Sequenziamento e grafi di de Brujin}
\end{frame}

\begin{frame}[fragile]
\frametitle{Velvet}
\end{frame}



\begin{comment}
\begin{frame}[fragile]
\frametitle{SAIS}
\lstinputlisting{code/sais/sais.c}
\end{frame}


\begin{frame}[fragile]
\frametitle{SAIS}
\lstinputlisting{code/sais/sais_main.1}
\end{frame}
\end{comment}


%  \begin{frame}
%    \frametitle{Consensus Clustering}
%    \begin{block}{Problem}
%      \alert{Input}: set $\Pi$ of partitions of $U$\\
%      \alert{Output}: a partition $P$ of $U$\\
%      \alert{Goal}: $P$ the best possible representative of $\Pi$
%    \end{block}

%    \begin{block}{Objective Function}
%      \begin{itemize}
%      \item
%        Symmetric difference between two partitions =
%        Pairs of elements clustered differently
%      \item
%        $d(P,\Pi)=\sum_{\pi\in \Pi}d(\pi,P)$
%      \end{itemize}
%    \end{block}
%  \end{frame}



% \begin{frame}\frametitle{Finestre}
%   \begin{itemize}
%   \item
%     Editor (F5)
%   \item
%     Log (F6)
%   \item
%     Output (F7)
%   \item
%     Icona Esegui (F8)
%   \end{itemize}
% \end{frame}




\begin{frame}[containsverbatim]\frametitle{Licenza d'uso}
  \small

  Quest'opera {\`e} soggetta alla licenza Creative Commons: Attribuzione-Condividi
  allo stesso modo 3.0.

  \verb+http://creativecommons.org/licenses/by-sa/3.0/+

  Sei libero di riprodurre, distribuire, comunicare al pubblico, esporre in
  pubblico, rappresentare, eseguire, recitare e modificare quest'opera
  alle seguenti condizioni:
  \begin{itemize}
  \item
    Attribuzione — Devi attribuire la paternit{\`a} dell'opera nei modi indicati
    dall'autore o da chi ti ha dato l'opera in licenza e in modo tale da non
    suggerire che essi avallino te o il modo in cui tu usi l'opera.
  \item
    Condividi allo stesso modo — Se alteri o trasformi quest'opera, o se la usi
    per crearne un'altra, puoi distribuire l'opera risultante solo con una licenza
    identica o equivalente a  questa.
  \end{itemize}
  \vspace*{1cm}
\end{frame}



\begin{comment}
\begin{frame}[fragile]
\frametitle{SAIS}
\begin{block}{S-type/L-type suffix}
\begin{itemize}
\item
$S[i:]$ e $S[i]$ sono  S-type se $S[i:] < S[i+1:]$
\item
$S[i:]$ e $S[i]$ sono  L-type se $S[i:] > S[i+1:]$
\item
$S[n-1:]$ è S-type
\end{itemize}
\end{block}

\begin{block}{Test S-type}
$S[i]$ è S-type se:
\begin{enumerate}
\item
$S[i] < S[i + 1]$ oppure
\item
$S[i] = S[i + 1]$ e  $S[i + 1]$ sono S-type
\end{enumerate}
\end{block}
\end{frame}

\begin{frame}[fragile]
\frametitle{SAIS}
\begin{block}{Bucket}
Sottoarray dei suffissi che iniziano con lo stesso carattere
\end{block}
\begin{block}{S-type/L-type Bucket}
\begin{enumerate}
\item
All'interno di un bucket,  L-suffissi precedono S-suffissi
\item
L-bucket, S-bucket
\end{enumerate}
\end{block}
\end{frame}

\begin{frame}[fragile]
\frametitle{SAIS}
\alert{LMS}: Leftmost S-type
\begin{block}{LMS character}
$S[i]$ è LMS se $S[i]$ è S-type e $S[i-1]$ è L-type
\end{block}
\begin{block}{LMS suffix}
$S[i:]$ è LMS se $S[i]$ è LMS
\end{block}
\begin{block}{LMS substring}
\begin{itemize}
\item
$S[n-1:n-1]$ è LMS
\item
$S[i:j]$ è LMS se $S[i]$ e $S[j]$ sono LMS e nessun $S[l]$ con $i<l<j$ è LMS
\end{itemize}
\end{block}
\end{frame}


\begin{frame}[fragile]
\frametitle{SAIS: sais.h}
\lstinputlisting{code/sais/sais.h}
\begin{block}{Parametri}
\begin{itemize}
\item
\verb!k!: dimensione alfabeto
\item
\verb!n!: lunghezza testo
\item
\verb!T!: Testo
\item
\verb!SA!: Suffix Array
\end{itemize}
\end{block}
\end{frame}

\begin{frame}[fragile]
\frametitle{SAIS: main}
\lstinputlisting{code/sais/sais_int.c}
\onslide<2->{\lstinline+sais_main+ gestisce i casi non banali}
\end{frame}




\begin{frame}[fragile]
\frametitle{SAIS}
\lstinputlisting{code/sais/sais.C-alphabet.c}
\end{frame}

\begin{frame}[fragile]
\frametitle{SAIS}
\lstinputlisting{code/sais/sais.start-end-bucket.c}
  \begin{itemize}[<+->]
  \item
Come migliorare il codice?
\item
12: \lstinline!B[i]=sum; sum+=C[i];!
\end{itemize}
\end{frame}


\begin{frame}[fragile]
\frametitle{SAIS: sais\_main}
\lstinputlisting{code/sais/sais_main.1}
code/sais/sais.c
\end{frame}


\begin{frame}[fragile]
\frametitle{SAIS: sais\_main}
\lstinputlisting{code/sais/sais_main.2}
\end{frame}


\begin{frame}[fragile]
\frametitle{SAIS: sais\_main}
\lstinputlisting{code/sais/sais_main.2.1}
\end{frame}


\begin{frame}[fragile]
\frametitle{SAIS: sais\_main}
\lstinputlisting{code/sais/sais_main.3}
\end{frame}
\end{comment}


\end{document}
%%% Local Variables:
%%% TeX-PDF-mode: t
%%% TeX-master: "lucidi_bioinformatica_video"
%%% buffer-file-coding-system: utf-8
%%% End:
